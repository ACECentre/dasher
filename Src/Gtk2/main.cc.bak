#include <sys/types.h>
#include <sys/time.h>

#include <iostream>
#include <gtk/gtk.h>
#include <gdk/gdk.h>

#include "DasherInterface.h"
#include "Gtk2DasherEdit.h"
#include "Gtk2DasherCanvas.h"
#include "Gtk2DasherPane.h"

GtkWidget *window;

bool paused=false;
bool setup;

typedef struct {
  Gtk2DasherEdit *dasher_text;
} Gtk2DasherComponents;

long get_time() {
  long s_now;
  long ms_now;
   
  struct timeval tv;
  struct timezone tz;
   
  gettimeofday (&tv, &tz);
   
  s_now = tv.tv_sec;
  ms_now = tv.tv_usec / 1000;
   
  return (s_now * 1000 + ms_now);
}

static gint timer_callback(gpointer data)
{
  Gtk2DasherCanvas *dasher_canvas = static_cast<Gtk2DasherCanvas*>(data);
   
  if (!paused) {
    int x;
    int y;

    gdk_window_get_pointer(dasher_canvas->canvas->window, &x, &y, NULL);
    dasher_canvas->interface->TapOn(x,y,get_time());
  }
  
  // need non-zero return value so timer repeats
  return 1;
}


static void open_window (void) 
{
  GtkWidget *vbox, *toolbar;
  GdkPixbuf *p;
  GtkWidget *text_view;
  GtkWidget *text_scrolled_window;
  GtkWidget *canvas_frame;
  GtkStyle *style;

  Gtk2DasherCanvas *dasher_canvas;
  Gtk2DasherPane *dasher_pane;
  Gtk2DasherEdit *dasher_text_view;

  CDasherInterface *interface;

  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
  vbox = gtk_vbox_new (FALSE, 2);
  gtk_window_set_title (GTK_WINDOW(window), "Dasher");
  gtk_window_set_policy (GTK_WINDOW(window), FALSE, FALSE, FALSE);

  interface = new CDasherInterface;

  dasher_canvas = new Gtk2DasherCanvas (100, 100, interface);
  dasher_text_view = new Gtk2DasherEdit (interface);

  dasher_pane = new Gtk2DasherPane (dasher_canvas, dasher_text_view);

  toolbar = gtk_toolbar_new();
  gtk_toolbar_set_orientation (GTK_TOOLBAR (toolbar), GTK_ORIENTATION_HORIZONTAL);
  gtk_toolbar_set_style (GTK_TOOLBAR (toolbar), GTK_TOOLBAR_ICONS);

  gtk_box_pack_start (GTK_BOX (vbox), toolbar, FALSE, FALSE, 0);
  text_scrolled_window = gtk_scrolled_window_new (NULL, NULL);
  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW(text_scrolled_window), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
  gtk_box_pack_start (GTK_BOX(vbox), text_scrolled_window, FALSE, FALSE, 0);
  
  gtk_container_add (GTK_CONTAINER (text_scrolled_window), dasher_text_view->text_view);

  canvas_frame = gtk_frame_new (NULL);
  gtk_box_pack_start (GTK_BOX (vbox), canvas_frame, TRUE, TRUE, 0);
  gtk_container_add (GTK_CONTAINER (canvas_frame), dasher_canvas->canvas);

  gtk_container_add (GTK_CONTAINER (window), vbox);
  gtk_widget_set_usize (GTK_WIDGET (window), 200, 200);

  gtk_widget_realize (window);
  gtk_widget_realize (vbox);
  gtk_widget_realize (text_scrolled_window);
  gtk_widget_realize (dasher_text_view->text_view);
  gtk_widget_realize (toolbar);
  gtk_widget_realize (canvas_frame);
  gtk_widget_realize (dasher_canvas->canvas);
  
  gtk_widget_show (window);
  gtk_widget_show (vbox);
  gtk_widget_show (text_scrolled_window);
  gtk_widget_show (dasher_text_view->text_view);
  gtk_widget_show (toolbar);
  gtk_widget_show (canvas_frame);
  gtk_widget_show (dasher_canvas->canvas);

  interface->ChangeLanguageModel(0);
  interface->ChangeView(0);
  
  std::vector < std::string > alphabetlist;
  interface->GetAlphabets ( &alphabetlist );
  
  interface->ChangeAlphabet( alphabetlist[0] );

  interface->ChangeEdit(dasher_text_view);
  interface->ChangeScreen(dasher_canvas->wrapper);

  interface->Start();

  gtk_timeout_add(50, timer_callback, dasher_canvas);

  setup = TRUE;

}

int main(int argc, char *argv[])
{
  gtk_init (&argc, &argv);
  open_window();
  gtk_main();
  return 0;
}




